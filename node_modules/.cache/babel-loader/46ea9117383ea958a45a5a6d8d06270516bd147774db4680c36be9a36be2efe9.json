{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport * as api from '../lib/api';\nimport { SocketEvents } from '../shared/types';\nexport class Store {\n  constructor() {\n    this.page = 'posts';\n    this.error = '';\n    this.connected = false;\n    this.alias = '';\n    this.balance = 0;\n    this.pubkey = '';\n    this.makeItRain = false;\n    this.posts = [];\n    this.showPayModal = false;\n    this.pmtForPost = void 0;\n    this.pmtAmount = '';\n    this.pmtRequest = '';\n    this.pmtHash = '';\n    this.pmtSuccessMsg = '';\n    this.pmtError = '';\n    this.gotoPosts = () => this.page = 'posts';\n    this.gotoCreate = () => this.page = this.connected ? 'create' : 'connect';\n    this.gotoConnect = () => this.page = 'connect';\n    this.clearError = () => this.error = '';\n    this.init = async () => {\n      // try to fetch the node's info on startup\n      try {\n        await this.fetchInfo();\n        this.connected = true;\n      } catch (err) {\n        // don't display an error, just disconnect\n        this.connected = false;\n      }\n\n      // fetch the posts from the backend\n      try {\n        this.posts = await api.fetchPosts();\n      } catch (err) {\n        this.error = err.message;\n      }\n\n      // connect to the backend WebSocket and listen for events\n      const ws = api.getEventsSocket();\n      ws.addEventListener('message', this.onSocketMessage);\n    };\n    this.connectToLnd = async (host, cert, macaroon) => {\n      this.clearError();\n      try {\n        await api.connect(host, cert, macaroon);\n        this.connected = true;\n        this.fetchInfo();\n        this.gotoPosts();\n      } catch (er) {\n        this.error = er.message;\n      }\n    };\n    this.disconnect = () => {\n      api.clearToken();\n      this.connected = false;\n    };\n    this.fetchInfo = async () => {\n      const info = await api.getInfo();\n      this.alias = info.alias;\n      this.balance = parseInt(info.balance);\n      this.pubkey = info.pubkey;\n    };\n    this.fetchPosts = async () => {\n      this.clearError();\n      try {\n        this.posts = await api.fetchPosts();\n      } catch (err) {\n        this.error = err.message;\n      }\n    };\n    this.createPost = async (title, content) => {\n      this.clearError();\n      try {\n        await api.createPost(title, content);\n        this.gotoPosts();\n      } catch (err) {\n        this.error = err.message;\n      }\n    };\n    this.upvotePost = async () => {\n      this.pmtError = '';\n      try {\n        if (!this.pmtForPost) throw new Error('No post selected to upvote');\n        await api.upvotePost(this.pmtForPost.id, this.pmtHash);\n        this.pmtSuccessMsg = `Your payment of ${this.pmtAmount} sats to ${this.pmtForPost.username} was successful! The post has been upvoted!`;\n      } catch (err) {\n        this.pmtError = err.message;\n      }\n    };\n    this.verifyPost = async postId => {\n      this.clearError();\n      try {\n        const post = await api.verifyPost(postId);\n        this._updatePost(post);\n      } catch (err) {\n        this.error = err.message;\n      }\n    };\n    this.showPaymentRequest = async post => {\n      this.clearError();\n      try {\n        const res = await api.createInvoice(post.id);\n        this.pmtForPost = post;\n        this.pmtAmount = res.amount;\n        this.pmtRequest = res.payreq;\n        this.pmtHash = res.hash;\n        this.pmtSuccessMsg = '';\n        this.pmtError = '';\n        this.showPayModal = true;\n      } catch (err) {\n        this.error = err.message;\n      }\n    };\n    this.hidePaymentRequest = () => {\n      this.pmtForPost = undefined;\n      this.pmtAmount = '';\n      this.pmtRequest = '';\n      this.pmtHash = '';\n      this.pmtSuccessMsg = '';\n      this.pmtError = '';\n      this.showPayModal = false;\n    };\n    this.onSocketMessage = msg => {\n      const event = JSON.parse(msg.data);\n      // update the posts array when a post is updated on the server\n      if (event.type === SocketEvents.postUpdated) {\n        // replacing the existing post with this new one\n        this._updatePost(event.data);\n      }\n      if (event.type === SocketEvents.invoicePaid) {\n        const {\n          hash,\n          amount,\n          pubkey\n        } = event.data;\n        // upvote the post when the incoming payment is made for the\n        // pmtHash the we are waiting for\n        if (hash === this.pmtHash) {\n          this.upvotePost();\n        }\n        // update the balance when an invoice is paid to the current user\n        if (pubkey === this.pubkey) {\n          this._incrementBalance(parseInt(amount));\n        }\n      }\n    };\n    this._incrementBalance = amount => {\n      this.balance = this.balance + amount;\n\n      // make it rain for 3 seconds ðŸ’¸\n      this.makeItRain = true;\n      setTimeout(() => {\n        this.makeItRain = false;\n      }, 3000);\n    };\n    this._updatePost = post => {\n      this.posts = [\n      // the updated post\n      post,\n      // the existing posts excluding the one that was updated\n      ...this.posts.filter(p => p.id !== post.id)];\n    };\n    makeAutoObservable(this);\n    this.init();\n  }\n\n  //\n  // Observable state objects\n  //\n\n  // App state\n\n  //\n  // Computed props\n  //\n\n  get sortedPosts() {\n    return this.posts.slice().sort((a, b) => {\n      // sort by votes desc if they are not equal\n      if (a.votes !== b.votes) return b.votes - a.votes;\n      // sort by id if they have the same votes\n      return a.id - b.id;\n    });\n  }\n\n  //\n  // Actions\n  //\n}","map":{"version":3,"names":["makeAutoObservable","api","SocketEvents","Store","constructor","page","error","connected","alias","balance","pubkey","makeItRain","posts","showPayModal","pmtForPost","pmtAmount","pmtRequest","pmtHash","pmtSuccessMsg","pmtError","gotoPosts","gotoCreate","gotoConnect","clearError","init","fetchInfo","err","fetchPosts","message","ws","getEventsSocket","addEventListener","onSocketMessage","connectToLnd","host","cert","macaroon","connect","er","disconnect","clearToken","info","getInfo","parseInt","createPost","title","content","upvotePost","Error","id","username","verifyPost","postId","post","_updatePost","showPaymentRequest","res","createInvoice","amount","payreq","hash","hidePaymentRequest","undefined","msg","event","JSON","parse","data","type","postUpdated","invoicePaid","_incrementBalance","setTimeout","filter","p","sortedPosts","slice","sort","a","b","votes"],"sources":["C:/Users/rodri/Desktop/builders-guide-sample-app/src/store/store.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\r\nimport * as api from '../lib/api';\r\nimport { Post, SocketEvents } from '../shared/types';\r\n\r\nexport class Store {\r\n  constructor() {\r\n    makeAutoObservable(this);\r\n\r\n    this.init();\r\n  }\r\n\r\n  //\r\n  // Observable state objects\r\n  //\r\n\r\n  // App state\r\n  page = 'posts';\r\n  error = '';\r\n  connected = false;\r\n  alias = '';\r\n  balance = 0;\r\n  pubkey = '';\r\n  makeItRain = false;\r\n\r\n  // PostList state\r\n  posts: Post[] = [];\r\n\r\n  // PayModal state\r\n  showPayModal = false;\r\n  pmtForPost: Post | undefined;\r\n  pmtAmount = '';\r\n  pmtRequest = '';\r\n  pmtHash = '';\r\n  pmtSuccessMsg = '';\r\n  pmtError = '';\r\n\r\n  //\r\n  // Computed props\r\n  //\r\n\r\n  get sortedPosts() {\r\n    return this.posts.slice().sort((a, b) => {\r\n      // sort by votes desc if they are not equal\r\n      if (a.votes !== b.votes) return b.votes - a.votes;\r\n      // sort by id if they have the same votes\r\n      return a.id - b.id;\r\n    });\r\n  }\r\n\r\n  //\r\n  // Actions\r\n  //\r\n\r\n  gotoPosts = () => (this.page = 'posts');\r\n  gotoCreate = () => (this.page = this.connected ? 'create' : 'connect');\r\n  gotoConnect = () => (this.page = 'connect');\r\n\r\n  clearError = () => (this.error = '');\r\n\r\n  init = async () => {\r\n    // try to fetch the node's info on startup\r\n    try {\r\n      await this.fetchInfo();\r\n      this.connected = true;\r\n    } catch (err) {\r\n      // don't display an error, just disconnect\r\n      this.connected = false;\r\n    }\r\n\r\n    // fetch the posts from the backend\r\n    try {\r\n      this.posts = await api.fetchPosts();\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n\r\n    // connect to the backend WebSocket and listen for events\r\n    const ws = api.getEventsSocket();\r\n    ws.addEventListener('message', this.onSocketMessage);\r\n  };\r\n\r\n  connectToLnd = async (host: string, cert: string, macaroon: string) => {\r\n    this.clearError();\r\n    try {\r\n      await api.connect(host, cert, macaroon);\r\n      this.connected = true;\r\n      this.fetchInfo();\r\n      this.gotoPosts();\r\n    } catch (er) {\r\n      this.error = er.message;\r\n    }\r\n  };\r\n\r\n  disconnect = () => {\r\n    api.clearToken();\r\n    this.connected = false;\r\n  };\r\n\r\n  fetchInfo = async () => {\r\n    const info = await api.getInfo();\r\n    this.alias = info.alias;\r\n    this.balance = parseInt(info.balance);\r\n    this.pubkey = info.pubkey;\r\n  };\r\n\r\n  fetchPosts = async () => {\r\n    this.clearError();\r\n    try {\r\n      this.posts = await api.fetchPosts();\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n  };\r\n\r\n  createPost = async (title: string, content: string) => {\r\n    this.clearError();\r\n    try {\r\n      await api.createPost(title, content);\r\n      this.gotoPosts();\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n  };\r\n\r\n  upvotePost = async () => {\r\n    this.pmtError = '';\r\n    try {\r\n      if (!this.pmtForPost) throw new Error('No post selected to upvote');\r\n      await api.upvotePost(this.pmtForPost.id, this.pmtHash);\r\n      this.pmtSuccessMsg = `Your payment of ${this.pmtAmount} sats to ${this.pmtForPost.username} was successful! The post has been upvoted!`;\r\n    } catch (err) {\r\n      this.pmtError = err.message;\r\n    }\r\n  };\r\n\r\n  verifyPost = async (postId: number) => {\r\n    this.clearError();\r\n    try {\r\n      const post = await api.verifyPost(postId);\r\n      this._updatePost(post);\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n  };\r\n\r\n  showPaymentRequest = async (post: Post) => {\r\n    this.clearError();\r\n    try {\r\n      const res = await api.createInvoice(post.id);\r\n      this.pmtForPost = post;\r\n      this.pmtAmount = res.amount;\r\n      this.pmtRequest = res.payreq;\r\n      this.pmtHash = res.hash;\r\n      this.pmtSuccessMsg = '';\r\n      this.pmtError = '';\r\n      this.showPayModal = true;\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n  };\r\n\r\n  hidePaymentRequest = () => {\r\n    this.pmtForPost = undefined;\r\n    this.pmtAmount = '';\r\n    this.pmtRequest = '';\r\n    this.pmtHash = '';\r\n    this.pmtSuccessMsg = '';\r\n    this.pmtError = '';\r\n    this.showPayModal = false;\r\n  };\r\n\r\n  //\r\n  // WebSocket listener\r\n  //\r\n\r\n  onSocketMessage = (msg: MessageEvent) => {\r\n    const event = JSON.parse(msg.data);\r\n    // update the posts array when a post is updated on the server\r\n    if (event.type === SocketEvents.postUpdated) {\r\n      // replacing the existing post with this new one\r\n      this._updatePost(event.data);\r\n    }\r\n    if (event.type === SocketEvents.invoicePaid) {\r\n      const { hash, amount, pubkey } = event.data;\r\n      // upvote the post when the incoming payment is made for the\r\n      // pmtHash the we are waiting for\r\n      if (hash === this.pmtHash) {\r\n        this.upvotePost();\r\n      }\r\n      // update the balance when an invoice is paid to the current user\r\n      if (pubkey === this.pubkey) {\r\n        this._incrementBalance(parseInt(amount));\r\n      }\r\n    }\r\n  };\r\n\r\n  //\r\n  // Private helper methods\r\n  //\r\n  private _incrementBalance = (amount: number) => {\r\n    this.balance = this.balance + amount;\r\n\r\n    // make it rain for 3 seconds ðŸ’¸\r\n    this.makeItRain = true;\r\n    setTimeout(() => {\r\n      this.makeItRain = false;\r\n    }, 3000);\r\n  };\r\n\r\n  private _updatePost = (post: Post) => {\r\n    this.posts = [\r\n      // the updated post\r\n      post,\r\n      // the existing posts excluding the one that was updated\r\n      ...this.posts.filter(p => p.id !== post.id),\r\n    ];\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}