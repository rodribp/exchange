{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport * as api from '../lib/api';\nimport { SocketEvents } from '../shared/types';\nexport class Store {\n  constructor() {\n    this.page = 'posts';\n    this.error = '';\n    this.posts = [];\n    this.gotoPosts = () => this.page = 'posts';\n    this.gotoCreate = () => this.page = 'create';\n    this.clearError = () => this.error = '';\n    this.init = async () => {\n      // fetch the posts from the backend\n      this.fetchPosts();\n\n      // connect to the backend WebSocket and listen for events\n      const ws = api.getEventsSocket();\n      ws.addEventListener('message', this.onSocketMessage);\n    };\n    this.fetchPosts = async () => {\n      this.clearError();\n      try {\n        this.posts = await api.fetchPosts();\n      } catch (err) {\n        this.error = err.message;\n      }\n    };\n    this.createPost = async (username, title, content) => {\n      this.clearError();\n      try {\n        await api.createPost(username, title, content);\n        this.gotoPosts();\n      } catch (err) {\n        this.error = err.message;\n      }\n    };\n    this.upvotePost = async post => {\n      this.clearError();\n      try {\n        await api.upvotePost(post.id);\n      } catch (err) {\n        this.error = err.message;\n      }\n    };\n    this.onSocketMessage = msg => {\n      const event = JSON.parse(msg.data);\n      // update the posts array when a post is updated on the server\n      if (event.type === SocketEvents.postUpdated) {\n        // replacing the existing post with this new one\n        this._updatePost(event.data);\n      }\n    };\n    this._updatePost = post => {\n      this.posts = [\n      // the updated post\n      post,\n      // the existing posts excluding the one that was updated\n      ...this.posts.filter(p => p.id !== post.id)];\n    };\n    makeAutoObservable(this);\n    this.init();\n  }\n\n  //\n  // Observable state objects\n  //\n\n  // App state\n\n  //\n  // Computed props\n  //\n\n  get sortedPosts() {\n    return this.posts.slice().sort((a, b) => {\n      // sort by votes desc if they are not equal\n      if (a.votes !== b.votes) return b.votes - a.votes;\n      // sort by id if they have the same votes\n      return a.id - b.id;\n    });\n  }\n\n  //\n  // Actions\n  //\n}","map":{"version":3,"names":["makeAutoObservable","api","SocketEvents","Store","constructor","page","error","posts","gotoPosts","gotoCreate","clearError","init","fetchPosts","ws","getEventsSocket","addEventListener","onSocketMessage","err","message","createPost","username","title","content","upvotePost","post","id","msg","event","JSON","parse","data","type","postUpdated","_updatePost","filter","p","sortedPosts","slice","sort","a","b","votes"],"sources":["C:/Users/rodri/Desktop/builders-guide-sample-app/src/store/store.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\r\nimport * as api from '../lib/api';\r\nimport { Post, SocketEvents } from '../shared/types';\r\n\r\nexport class Store {\r\n  constructor() {\r\n    makeAutoObservable(this);\r\n\r\n    this.init();\r\n  }\r\n\r\n  //\r\n  // Observable state objects\r\n  //\r\n\r\n  // App state\r\n  page = 'posts';\r\n  error = '';\r\n\r\n  // PostList state\r\n  posts: Post[] = [];\r\n\r\n  //\r\n  // Computed props\r\n  //\r\n\r\n  get sortedPosts() {\r\n    return this.posts.slice().sort((a, b) => {\r\n      // sort by votes desc if they are not equal\r\n      if (a.votes !== b.votes) return b.votes - a.votes;\r\n      // sort by id if they have the same votes\r\n      return a.id - b.id;\r\n    });\r\n  }\r\n\r\n  //\r\n  // Actions\r\n  //\r\n\r\n  gotoPosts = () => (this.page = 'posts');\r\n  gotoCreate = () => (this.page = 'create');\r\n\r\n  clearError = () => (this.error = '');\r\n\r\n  init = async () => {\r\n    // fetch the posts from the backend\r\n    this.fetchPosts();\r\n\r\n    // connect to the backend WebSocket and listen for events\r\n    const ws = api.getEventsSocket();\r\n    ws.addEventListener('message', this.onSocketMessage);\r\n  };\r\n\r\n  fetchPosts = async () => {\r\n    this.clearError();\r\n    try {\r\n      this.posts = await api.fetchPosts();\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n  };\r\n\r\n  createPost = async (username: string, title: string, content: string) => {\r\n    this.clearError();\r\n    try {\r\n      await api.createPost(username, title, content);\r\n      this.gotoPosts();\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n  };\r\n\r\n  upvotePost = async (post: Post) => {\r\n    this.clearError();\r\n    try {\r\n      await api.upvotePost(post.id);\r\n    } catch (err) {\r\n      this.error = err.message;\r\n    }\r\n  };\r\n\r\n  //\r\n  // WebSocket listener\r\n  //\r\n\r\n  onSocketMessage = (msg: MessageEvent) => {\r\n    const event = JSON.parse(msg.data);\r\n    // update the posts array when a post is updated on the server\r\n    if (event.type === SocketEvents.postUpdated) {\r\n      // replacing the existing post with this new one\r\n      this._updatePost(event.data);\r\n    }\r\n  };\r\n\r\n  //\r\n  // Private helper methods\r\n  //\r\n\r\n  private _updatePost = (post: Post) => {\r\n    this.posts = [\r\n      // the updated post\r\n      post,\r\n      // the existing posts excluding the one that was updated\r\n      ...this.posts.filter((p) => p.id !== post.id),\r\n    ];\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}